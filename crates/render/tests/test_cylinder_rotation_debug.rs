use glam::Vec3;

#[test]
fn debug_cylinder_rotation_issue() {
    println!("\n=== Debugging Cylinder Rotation Issue ===\n");
    
    // Test case: Z-axis rotation as generated by physics
    let physics_angles = [0.1f32, -0.1, -0.5, 0.5];  // radians
    
    for angle in physics_angles {
        println!("Testing angle: {:.3} rad ({:.1}°)", angle, angle.to_degrees());
        
        // Physics generates quaternion for Z-axis rotation
        let half_angle = angle * 0.5;
        let physics_quat = [
            0.0,                    // x
            0.0,                    // y
            half_angle.sin(),       // z
            half_angle.cos(),       // w
        ];
        
        println!("  Physics quaternion: [{:.3}, {:.3}, {:.3}, {:.3}]", 
                 physics_quat[0], physics_quat[1], physics_quat[2], physics_quat[3]);
        
        // Test the shader's quaternion rotation function
        let test_point = Vec3::new(0.0, 1.0, 0.0); // Top of cylinder
        let rotated = shader_rotate_point(test_point, physics_quat);
        
        println!("  Point (0, 1, 0) rotated to: ({:.3}, {:.3}, {:.3})", 
                 rotated.x, rotated.y, rotated.z);
        
        // Expected result for Z-axis rotation
        let expected_x = -angle.sin();
        let expected_y = angle.cos();
        println!("  Expected: ({:.3}, {:.3}, 0.000)", expected_x, expected_y);
        
        // Check if rotation is correct
        let error_x = (rotated.x - expected_x).abs();
        let error_y = (rotated.y - expected_y).abs();
        let error_z = rotated.z.abs();
        
        if error_x > 0.001 || error_y > 0.001 || error_z > 0.001 {
            println!("  ❌ ERROR: Rotation doesn't match expected!");
        } else {
            println!("  ✅ Rotation is correct");
        }
        
        // Test the conjugate (inverse) rotation used in the shader
        let conjugate = [-physics_quat[0], -physics_quat[1], -physics_quat[2], physics_quat[3]];
        let inverse_rotated = shader_rotate_point(rotated, conjugate);
        
        println!("  Inverse rotation result: ({:.3}, {:.3}, {:.3})", 
                 inverse_rotated.x, inverse_rotated.y, inverse_rotated.z);
        
        // Should get back to (0, 1, 0)
        if (inverse_rotated - test_point).length() > 0.001 {
            println!("  ❌ ERROR: Inverse rotation doesn't restore original point!");
        } else {
            println!("  ✅ Inverse rotation is correct");
        }
        
        println!();
    }
}

// Matches the shader's quaternion_rotate_point function
fn shader_rotate_point(p: Vec3, q: [f32; 4]) -> Vec3 {
    let qv = Vec3::new(q[0], q[1], q[2]);
    let qw = q[3];
    p + 2.0 * qv.cross(qv.cross(p) + qw * p)
}

#[test]
fn test_cylinder_local_space_transform() {
    println!("\n=== Testing Cylinder Local Space Transform ===\n");
    
    // Scenario: Cylinder is rotated 30 degrees around Z
    let cylinder_angle = 30.0_f32.to_radians();
    let half_angle = cylinder_angle * 0.5;
    let cylinder_orientation = [0.0, 0.0, half_angle.sin(), half_angle.cos()];
    
    println!("Cylinder rotated {:.1}° around Z", cylinder_angle.to_degrees());
    println!("Orientation quaternion: [{:.3}, {:.3}, {:.3}, {:.3}]", 
             cylinder_orientation[0], cylinder_orientation[1], 
             cylinder_orientation[2], cylinder_orientation[3]);
    
    // Test points in world space
    let test_points = [
        (Vec3::new(0.0, 1.0, 0.0), "Top center"),
        (Vec3::new(0.5, 0.0, 0.0), "Right side"),
        (Vec3::new(0.0, 0.0, 0.5), "Front side"),
    ];
    
    for (world_point, description) in test_points {
        println!("\nTesting {}: {:?}", description, world_point);
        
        // Apply inverse rotation to get local space (as shader does)
        let conjugate = [-cylinder_orientation[0], -cylinder_orientation[1], 
                        -cylinder_orientation[2], cylinder_orientation[3]];
        let local_point = shader_rotate_point(world_point, conjugate);
        
        println!("  Local space: ({:.3}, {:.3}, {:.3})", 
                 local_point.x, local_point.y, local_point.z);
        
        // For a cylinder aligned with Y-axis in local space,
        // the SDF calculation would use local_point
    }
}